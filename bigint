#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include<stdint.h>
#include <bitset>
#include<string>

typedef unsigned char BYTE;
using namespace std;

typedef struct Bigint
{
    BYTE sign = 0; // 1 is negative ,0 is positive
    int nbytes = 0;
    BYTE* data = NULL;
} bigint;

void freedata(bigint x)
{
    delete[]x.data;
    x.data = NULL;
    x.nbytes = 0;
}

bool IsNonZero(string s)
{
    int n = s.length();
    for (int i = 0; i < n; i++)
    {
        if (s[i] != '0')
            return 1;
    }
    return 0;
}

int Getnumberofdigit(string s)
{
    return s.length();
}

int countbytes(string s)
{
    int carry = 0;
    string res = "";
    int a = 0;
    int cnt = 0;
    int n = Getnumberofdigit(s);
    while (IsNonZero(s))
    {
        for (int i = 0; i < n; i++)
        {
            a = carry * 10 + (s[i] - '0');
            res += (a / 256) + '0';
            carry = (a % 256);
        }
        cnt++;
        s = res;
        res = "";
        carry = 0;
    }
    return cnt;
}

void allocation(bigint& x,string s)
{
    x.nbytes = countbytes(s);
    x.data = new BYTE[x.nbytes];
}

void DecimalToBigint(bigint& x, string s)
{
    int carry = 0;
    string res = "";
    int a = 0;
    int cnt = 0;
    int n = Getnumberofdigit(s);
    allocation(x, s);
    for(int i=0;i < x.nbytes;i++)
    {
        for (int i = 0; i < n; i++)
        {
            a = carry * 10 + (s[i] - '0');
            res += (a / 256) + '0';
            carry = (a % 256);
        }
        x.data[i] = carry;
        s = res;
        res = "";
        carry = 0;
    }
}

string decimaltobinary(BYTE n)
{
    string str = "";
    int cnt = 0;
    while (n > 0)
    {
        str += (n % 2) + '0';
        n /= 2;
        cnt++;
    }
    while (cnt < 8)
    {
        str += "0";
        cnt++;
    }
    reverse(str.begin(), str.end());
    return str;
}

string BigintToBinary(bigint x)
{
    string str = "";
    for (int i = x.nbytes-1; i >= 0; i--)
    {
        str+=decimaltobinary(x.data[i]);
    }
    int i = 0;
    while (str[i] == '0')
    {
        str.erase(str.begin());
    }
    return str;
}

int Getdigit(string x, int pos)
{
    int n = x.length();
    if (pos < n)
        return x[pos] -'0';
    return 0;
}

string operator+(string x,string y)
{
    reverse(x.begin(),x.end());
    reverse(y.begin(),y.end());
    int nx = x.length();
    int ny = y.length();
    int n = (nx > ny) ? nx : ny;
    string str = "";
    int tmp;
    int mem = 0;
    for (int i = 0; i < n; i++)
    {
        int a = Getdigit(x, i);
        int b = Getdigit(y, i);
        tmp = a + b + mem;
        if (tmp >= 10)
        {
            tmp = tmp - 10;
            mem = 1;
        }
        else
        {
            mem = 0;
        }
        str += (tmp + '0');
    }
    if (mem)
    {
        str += "1";
    }
    reverse(str.begin(), str.end());
    return str;
}

bigint operator+(bigint x, bigint y)
{
    bigint res;
    int nx = x.nbytes;
    int ny = y.nbytes;
    int n = (nx > ny) ? nx : ny;
    int mem = 0;
    res.data = new BYTE[n+1];
    if (n - ny > 0)
    {
        for (int i = 0; i < n; i++)
        {
            if (i < ny)
            {
                res.data[i] = x.data[i] + y.data[i] + mem;
                if (int(x.data[i] + y.data[i]) > 255)
                    mem = 1;
                else
                    mem = 0;
            }
            else
            {
                res.data[i] = x.data[i] + mem ;
                if (int(x.data[i]) + mem  > 255)
                    mem = 1;
                else
                    mem = 0;
            }
        }
    }
    else 
        if (n - nx > 0)
    {
        for (int i = 0; i < n; i++)
        {
            if (i < nx)
            {
                res.data[i] = x.data[i] + y.data[i] + mem;
                if (int(x.data[i] + y.data[i] + mem ) > 255)
                    mem = 1;
                else
                    mem = 0;
            }
            else
            {
                res.data[i] = y.data[i] + mem ;
                if (int(y.data[i]+mem) + mem  > 255)
                    mem = 1;
                else
                    mem = 0;
            }
        }
    }
    else
    {
        for (int i = 0; i < n; i++)
        {
            res.data[i] = x.data[i] + y.data[i] + mem;
            if (x.data[i] + y.data[i] + mem > 255)
                mem = 1;
            else
                mem = 0;
        }
        if (mem)
        {
            res.data[n] = mem;
            n++;
        }
    }
    res.nbytes = n;
    return res;
}

bigint operator*(bigint x,bigint y)
{
    bigint res;
    bigint tmp;
    int nx = x.nbytes;
    int ny = y.nbytes;
    int n = nx + ny ;
    res.data = new BYTE[n + 1];
    tmp.data = new BYTE[n + 1];
    res.nbytes = n;
    tmp.nbytes = n;
    int mem = 0;
    for (int i = 0; i <= n; i++)
    {
        res.data[i] = 0;
        tmp.data[i] = 0;
    }
    for (int i = 0; i < ny; i++)
    {  
        for (int j = 0; j < n; j++)
        {
            if (j < i)
                tmp.data[j] = 0;
            if (j >= i && j < nx + i)
            {
                tmp.data[j] = (x.data[j - i] * y.data[i] + mem);
                if (x.data[j - i] * y.data[i] + mem > 255)
                {
                    mem = (x.data[j - i] * y.data[i] + mem) / 256;
                }
                else
                    mem = 0;
            }
            else if (mem > 0 && j == nx + i)
            {
                tmp.data[j] = mem;
                mem = 0;
            }
            else
                tmp.data[j] = 0;
        }
        res = res + tmp;   
    }
    return res;
}

int BinaryToInt(string s)
{
    int res = 0;
    int n = s.length();
    int carry = 1;
    for (int i = n-1; i >= 0; i--)
    {
        res = res + (s[i] - '0') * carry ;
        carry = carry * 2;
    }
    return res;
}

void BinaryToBigint(bigint &x,string s)
{
    int n = s.length();
    int k = (8 - n % 8) % 8;
    reverse(s.begin(), s.end());
    for (int i = 0; i < k; i++)
    {
        s += "0";
    }
    reverse(s.begin(), s.end());
    int cnt = (n + k) / 8;
    x.nbytes = cnt;
    x.data = new BYTE[x.nbytes];
    for (int j=0;j<cnt;j++)
    {
        string str = "";
        for (int i = 8*j;i<8*(j+1);i++)
        {
            str += s[i];
        }
        x.data[cnt-1-j] = BinaryToInt(str);
    }
}

bool BigintNonZero(bigint x)
{
    int n = x.nbytes;
    for (int i = 0; i < n; i++)
    {
        if (x.data[i] != 0)
            return 1;
    }
    return 0;
}

string IntToString(int a)
{
    string str = "";
    while (a > 0)
    {
        str += (a % 10) + '0';
        a /= 10;
    }
    reverse(str.begin(), str.end());
    return str;
}

string operator*(string s, int num)
{
    string str = "0";
    string tmp = "0";
    int n = s.length();
    for (int i = n-1; i >= 0 ; i--)
    {
        int a = (s[i] - '0') * 256;
        tmp = IntToString(a);
        for (int j =0;j<n-1-i; j++)
        {
            tmp += "0";
        }
        str = str + tmp;
        tmp = "";
    }
    return str;
}

string BigintToDecimal(bigint x)
{
    string str = "0";
    string tmp;
    int n = x.nbytes;
    for (int i = 0; i < n; i++)
    {
        tmp = IntToString(x.data[i]);
        for (int j = 0; j < i; j++)
        {
            tmp = tmp * 256;
        }
        str = str + tmp;
    }
    return str;
}

string AddBinary(string x, string y)
{
    reverse(x.begin(), x.end());
    reverse(y.begin(), y.end());
    int nx = x.length();
    int ny = y.length();
    int n = (nx > ny) ? nx : ny;
    int carry = 0;
    int a = 0;
    string str = "";
    if (n - nx > 0)
        for (int i = nx; i < n; i++)
        {
            x += "0";
        }
    else
        for (int i = ny; i < n; i++)
            y += "0";
    for (int i = 0; i < n; i++)
    {
        a = (x[i] - '0') + (y[i] - '0') + carry;
        if (a > 1)
        {
            a = a - 2;
            carry = 1;
        }
        else
            carry = 0;
        str += a + '0';
    }
    if (carry > 0)
        str += "1";
    reverse(str.begin(), str.end());
    return str;
}

bool operator>(bigint x, bigint y)
{
    int nx = x.nbytes;
    int ny = y.nbytes;
    int n = (nx > ny) ? nx : ny;
    if (n - nx > 0)
    {
        for (int i = n - 1; i >= nx; i--)
        {
            if (y.data[i] > 0)
                return false;
        }
    }
    else if(n-ny>0)
    {
        for (int i = n - 1; i >= ny; i--)
        {
            if (x.data[i] > 0)
                return true;
        }
    }
    else
        for (int i = n - 1; i >= 0; i--)
        {
            if (x.data[i] > y.data[i])
                return true;
            if (x.data[i] < y.data[i])
                return false;
        }
    return 0;
}

bool operator<(bigint x, bigint y)
{
    int nx = x.nbytes;
    int ny = y.nbytes;
    int n = (nx > ny) ? nx : ny;
    if (n - nx > 0)
    {
        for (int i = n - 1; i >= nx; i--)
        {
            if (y.data[i] > 0)
                return true;
        }
    }
    else if (n - ny > 0)
    {
        for (int i = n - 1; i >= ny; i--)
        {
            if (x.data[i] > 0)
                return false;
        }
    }
    else
        for (int i = n - 1; i >= 0; i--)
        {
            if (x.data[i] > y.data[i])
                return false;
            if (x.data[i] < y.data[i])
                return true;
        }
    return 0;
}

bool operator==(bigint x, bigint y)
{
    return !((x < y) || (x > y));
}

bigint operator-(bigint x, bigint y)
{
    bigint res;
    int nx = x.nbytes;
    int ny = y.nbytes;
    int n = (nx > ny) ? nx : ny;
    int mem = 0;
    int tmp = 0;
    if (x == y)
    {
        n = 1;
        res.sign = 0;
        res.data = new BYTE[1];
        res.data[0] = 0;
    }
    else if (x > y)
    {
        res.data = new BYTE[n];
        res.sign = 0;
        for (int i = 0; i < ny; i++)
        {
            tmp = x.data[i] - y.data[i] - mem;
            if (tmp < 0)
            {
                tmp = x.data[i] + 10 - y.data[i] - mem;
                mem = 1;
            }
            else
                mem = 0;
            res.data[i] = tmp;
        }
        if (mem > 0)
            res.data[ny] = x.data[ny] - mem;
        for (int i = ny + 1; i < nx; i++)
        {
            res.data[i] = x.data[i];
        }
    }
    else
    {
        res.data = new BYTE[n];
        res.sign = 1;
        for (int i = 0; i < nx; i++)
        {
            tmp = y.data[i] - x.data[i] - mem;
            if (tmp < 0)
            {
                tmp = y.data[i] + 10 - x.data[i] - mem;
                mem = 1;
            }
            else
                mem = 0;
            res.data[i] = tmp;
        }
        if (mem > 0)
            res.data[nx] = y.data[nx] - mem;
        for (int i = nx + 1; i < ny; i++)
        {
            res.data[i] = y.data[i];
        }
    }  
    res.nbytes = n;
    return res;
}

int main()
{
    bigint x;
    bigint y;
    string t = "1231234";
    string s = "12312345";
    DecimalToBigint(x, s);
    DecimalToBigint(y, t);
    bigint z = x - y;
    cout << BigintToDecimal(z);
    //cout << BigintToBinary(z) << endl;
    freedata(x);
    freedata(y);
    freedata(z);
}